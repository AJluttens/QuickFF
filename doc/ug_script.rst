Running QuickFF using qff-est.py
################################

The most straightforward use of QuickFF is by means of a single command using 
the :ref:`qff-est.py <seclab_rg_qffest>` script. The basis usage of this script
is as follows::

    qff-est.py [options] fns

In the sections below, both the input files and the optional arguments are
discussed in detail. The description below is further illustrated with examples
in the :ref:`tutorials <seclab_tutorials>`.

.. _seclab_inputfiles:

Input files
===========

The script requires one or more input files describing the system, reference 
data and non-bonding part of the force field. These files are parsed to the 
program by means of the mandatory argument `fns` which is either a filename, or
a list of filenames seperated by spaces. The following list enumerates all 
possible formats of input files, as well as a specification of which kind of
information will be extracted from that particular file:

* **Gaussian formatted checkpoint file** (file.fchk): 

    a file generated using the 
    `formchk <http://www.gaussian.com/g_tech/g_ur/u_formchk.htm>`_ utility on a
    checkpoint file from a Gaussian 
    `freq <http://www.gaussian.com/g_tech/g_ur/k_freq.htm>`_ job. The atomic 
    numbers, equilibrium geometry and equilibrium Hessian are extracted from 
    this file.


* **HDF5 file** (file.h5):

    a `Hierarchical Data Format <http://www.hdfgroup.org/HDF5/>`_ Release 5 
    (HDF5) file (for example generated by 
    `Horton <http://theochem.github.com/horton/>`_) from which parameters for
    the non-bonding force field can be extracted. If the option 
    --ei-path=${EI_PATH} from the :ref:`qff-est.py <seclab_rg_qffest>` script 
    is specified, charges (and possibly atomic radii) will be taken from the 
    dataset `${EI_PATH}/charges` (and `${EI_PATH}/radii`). Analogously, if the
    option --vdw-path=${VDW_PATH} is specified, epsilon and sigma parameters 
    for the van der Waals interactions will be extracted from the datasets 
    `${VDW_PATH}/epsilons` and `${VDW_PATH}/sigmas`.


* **PSF file** (file.psf):

    a Protein Structure File (PSF) containing bond, bending and dihedral 
    patterns, atomic numbers, force field atom types and atomic charges. All
    this information is extracted.

* **MolMod checkpoint file** (file.chk, file.mfs):

    a checkpoint file with a simple format designed to be easily readable for
    post processing using Python tools (see the 
    `MolMod <http://molmod.github.io/molmod/>`_ package for more information). 
    The extracted information includes atomic numbers, atomic charges, 
    force field atom types, bond, bend, dihedral and out-of-plane patterns, 
    equilibrium geometry and equilibrium Hessian.

Duplicate information gets overwritten by files later in the `fns` arguments.
If no bond patterns are given, they are estimated by means of common bond
lengths. If no bend, dihedral and/or out-of-plane patterns are given, they are 
determined from the bond patterns. All this is done using the `MolecularGraph` 
class from the MolMod pakcage. If no charges are given, they are automatically
set to zero.

.. _seclab_ug_atype_estimator:

Automatic estimation of atom types
==================================
    
The optional argument :option:`--atypes-level` will trigger the automatic 
assignation of atom types to every atom in the system. There are four possible 
levels of assignation:

    - *low*: atom type is based on atom number
    - *medium*: atom type is based on atom number and number of neighbors. 
    - *high*: atom type is based on atom number, number of neighbors and the atom number of those neighbors. 
    - *highest*: every single atom is given a unique atom type based on its index in the system.

The levels `medium` and `high` are the most usefull, `medium` will result in 
higher transferability of the force field parameters, while `high` will
result in higher accuracy. The levels `low` and `highest` are mostly usefull
for debugging purposes. The automatic assignation for the levels `medium` 
and `high` is illustrated for three different molecules in the figures 
below. If the level `medium` is chosen, atom type strings will be of the 
form *EN* in which *E* is the element and *N* is the number of neighbors. 
When choosing atom types according to the level `high`, atom type strings 
will be of the form *ENs* in which *E* is the element, *N* is the number 
of neighbors and *s* is a string describing the neighbors. If the atom has 
only 1 neighbor, then *s* is equal *_e* with *e* the element of the 
neighbor. If the atom under consideration has 2 neighbors, then *s* is equal
to *_ee* in which the first and second *e* represent the element of the 
first and second neighbor respectively. If the atom has more than 2 
neighbors, then *s* will contain a substring *_en* for every neighboring 
atom that is either a carbon, a nitrogen or a oxygen atom. In this 
substring, *e* represents the neighbor element (and is either c, n or o) and
*n* is the number of neighbors of that particular neighbor element. 
Multiple instances of this *_en* string are ordered according to atomic 
number.

.. figure:: atypes_medium.png
    :scale: 50 %
    :alt: Medium-level atom types
    :align: center
    
    **Figure**: Medium-level atom types

.. figure:: atypes_high.png
    :scale: 50 %
    :alt: High-level atom types
    :align: center
    
    **Figure**: High-level atom types

By default, the automatic assignation is switched off and the atom types are
suposed to be defined in the :ref:`input files <seclab_inputfiles>`.

Internal Coordinates in the valence model
=========================================

The use of the optional argument :option:`--ic-ids` will allow one to define the 
internal coordinates that will be included in model of the covalent 
interactions. For every internal coordinate allowed by this option, a Harmonic 
or Cosine term will be added to the covalent energy. The value of this options 
should be a comma-separated list of identifiers specifying internal coordinates 
names. Each identifier can be a specific IC name (e.g. bond/C3_cc.H1_c) or can 
be one of the following strings: *bonds*, *angles*, *diheds* or *opdists*, 
in which case all bonds, angles, ... will be included. Additionally, one can 
also define this option value using the single string *all*, in which case all 
internal coordinates in the system will be attributed a valence term. By 
default, all internal coordinates will be included in the valence model.


Electrostatic interactions
==========================

* Model (:option:`--ei-model`):
    Defines the potential used for the electrostatic interactions. Can be 
    CoulPoint, CoulGauss, HarmPoint, HarmGauss or Zero. If CoulPoint/CoulGauss 
    is chosen, the exact Coulombic potential between point/gaussian charges 
    will be used to evaluate EI interactions. If HarmPoint/HarmGauss is chosen, 
    a second order Taylor expansion of the Coulomb potential is used. Harmonic
    is a lot faster and should already give accurate results. By default,
    the harmonic approximation to the point-charge interaction will be used 
    (HarmPoint).

* Scaling (:option:`--ei-scales`):
    Defines the scaling rule for the electrostatic interactions. Three 
    comma-separated floats are required. The first one sets the scale for atoms
    separated by 1 bond, the second for atoms separated by 2 bonds etc ... This
    option can also be used to exclude, for example, 1-2 bonded atoms by simply
    setting the first float to zero. By default, all interactions are left 
    unscaled, i.e. :option:`--ei-scales=1.0,1.0,1.0`

* Charges and atomic radii (:option:`--ei-path`):
    Defines the path in the HDF5 file, given as an input file, from which the 
    charges will be extracted. Charges (and atomic radii in case of Gaussian 
    charges) will be read from the dataset `${EI_PATH}/charges` (and 
    `${EI_PATH}/radii`) in the HDF5 file. 


Van der Waals interactions
==========================

* Model (:option:`--vdw-model`):
    Defines the potential used for van der Waals interactions. Can be LJ, MM3, 
    HarmLJ, HarmMM3 or Zero. If LJ/MM3 is chosen, the exact 
    Lennard-Jones/MM3-Buckingham potential will be used to evaluate van der 
    Waals interactions. If HarmLJ/HarmMM3 is chosen, a second order Taylor 
    expansion of the LJ/MM3 potential is used. Harmonic is a lot faster and
    should already give accurate results. If Zero is chosen, no van der Waals 
    interactions will be taken into account during the force field 
    parameterisation. By default, Zero is chosen.

* Scaling (:option:`--vdw-scales`):
    Defines the scaling rule for the van der Waals interactions. Three 
    comma-separated floats are required. The first one sets the scale for atoms
    separated by 1 bond, the second for atoms separated by 2 bonds etc ... This
    option can also be used to exclude, for example, 1-2 bonded atoms by simply
    setting the first float to zero. By default, 1-2 and 1-3 interactions are
    excluded (scale of zero) and 1-4 interactions are left unscaled, i.e. 
    :option:`--vdw-scales=0.0,0.0,1.0`

* Epsilons and sigmas (:option:`--vdw-path`):
    Defines the path in the HDF5 file, given as an input file, from which the 
    epsilon and sigma values will be extracted. Epsilons and sigmas will be 
    read from the dataset `${VDW_PATH}/charges` (`${VDW_PATH}/radii`) in the 
    HDF5 file.  

* Other force field (:option:`--vdw-from`):
    Defines from which force field to extract vdW parameters. If this value is 
    anythin else then None, the values extracted from a HDF5 file will be 
    overwritten. Currently only UFF is supported.

Parallel QuickFF
================

If Scoop is installed, it is possible to run QuickFF on multiple cores of a 
single node by using the optional argument :option:`--scoop`. Only the 
generation of the perturbation trajectories will be parallized as it is by far
the time determening step. The exact syntax to use QuickFF in parallel is::

    python -m scoop -n nproc /path/to/qff-est.py --scoop [options] fns

*nproc* is the number of processes that can be launched simultaneously. It is
important to note that one has to define the absolute path to the location of 
the `qff-est.py` script. Finally, `[options]` and `fns` have the same meaning as
in the serial version.

Miscellanous options
====================

* Output file suffix (:option:`--suffix`):
    Suffix that will be added to all output files. By default, no suffix is 
    added.

* Trajectory storing/loading (:option:`--fn-traj`):
    Depending if the given option argument corresponds to an existing file or 
    not, this option will load/save perturbation trajectories to/from a cPickled 
    file.


Output
======

During the derivation of the force field, QuickFF will dump some usefull
information to the screen including machine information, system information, 
model information, the force field parameters after the perturbation step and
the final force field parameters. Additionally, three output files are
generated:

* system.chk:

    A MolMod checkpoint file containing all system information. This file can be
    used to start new QuickFF calculations or to perform force field simulations
    using `Yaff <http://molmod.github.io/yaff/>`_ together with the file 
    pars_yaff.txt.

* pars_yaff.txt:
    
    A formatted text file defining the final force field. This file can be read
    by `Yaff <http://molmod.github.io/yaff/>`_ together with the file 
    system.chk, to perform force field simulations.

* pars_ffit2.txt

    A formatted text file defining the final force field. This file can be read
    by FFit2 to further fine tune the force field if desired.
