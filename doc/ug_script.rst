Running QuickFF using qff-est.py
################################

The most straightforward use of QuickFF is by means of a single command using 
the :ref:`qff-est.py <seclab_rg_qffest>` script. The basis usage of this script
is as follows::

    qff-est.py [options] fn

In the sections below, both the input files and the optional arguments are
discussed in detail. The description below is further illustrated with examples
in the :ref:`tutorials <seclab_tutorials>`.

.. _seclab_inputfiles:

Input files
===========

The script requires one input files describing the system and reference 
data. This file is provided to the program by means of the mandatory argument
`fn` which should be te filename of the file in question. The following list
enumerates all possible formats of input files:

* **Gaussian formatted checkpoint file** (file.fchk): 

    a file generated using the 
    `formchk <http://www.gaussian.com/g_tech/g_ur/u_formchk.htm>`_ utility on a
    checkpoint file from a Gaussian 
    `freq <http://www.gaussian.com/g_tech/g_ur/k_freq.htm>`_ job. The atomic 
    numbers, equilibrium geometry and equilibrium Hessian are extracted from 
    this file.


* **vasprun file** (vasprun.xml):

    a file generated by VASP during a frequency calculation

A first optional input file can be provided using the :option:`--chk-fn`
argument. This argument should be the filename of a Yaff .chk file describing
the system. This allows to control the topology of the system and the atom
types. If not provided, the topology will be guessed from the ab initio
data. The atom types can be estimated automatically using the optional argument
:option:`--atypes-level (see below).

A second optional input file can be provided using the :option:`--ncff-fn`
argument. This argument should be the filename of a Yaff force-field parameter
file that describes the non-covalent interactions in the system.

.. _seclab_ug_atype_estimator:

Automatic estimation of atom types
==================================
    
The optional argument :option:`--atypes-level` will trigger the automatic 
assignation of atom types to every atom in the system. There are four possible 
levels of assignation:

    - *low*: atom type is based on atom number
    - *medium*: atom type is based on atom number and number of neighbors. 
    - *high*: atom type is based on atom number, number of neighbors and the atom number of those neighbors. 
    - *highest*: every single atom is given a unique atom type based on its index in the system.

The levels `medium` and `high` are the most usefull, `medium` will result in 
higher transferability of the force field parameters, while `high` will
result in higher accuracy. The levels `low` and `highest` are mostly usefull
for debugging purposes. The automatic assignation for the levels `medium` 
and `high` is illustrated for three different molecules in the figures 
below. If the level `medium` is chosen, atom type strings will be of the 
form *EN* in which *E* is the element and *N* is the number of neighbors. 
When choosing atom types according to the level `high`, atom type strings 
will be of the form *ENs* in which *E* is the element, *N* is the number 
of neighbors and *s* is a string describing the neighbors. If the atom has 
only 1 neighbor, then *s* is equal *_e* with *e* the element of the 
neighbor. If the atom under consideration has 2 neighbors, then *s* is equal
to *_ee* in which the first and second *e* represent the element of the 
first and second neighbor respectively. If the atom has more than 2 
neighbors, then *s* will contain a substring *_en* for every neighboring 
atom that is either a carbon, a nitrogen or a oxygen atom. In this 
substring, *e* represents the neighbor element (and is either c, n or o) and
*n* is the number of neighbors of that particular neighbor element. 
Multiple instances of this *_en* string are ordered according to atomic 
number.

.. figure:: atypes_medium.png
    :scale: 50 %
    :alt: Medium-level atom types
    :align: center
    
    **Figure**: Medium-level atom types

.. figure:: atypes_high.png
    :scale: 50 %
    :alt: High-level atom types
    :align: center
    
    **Figure**: High-level atom types

By default, the automatic assignation is switched off and the atom types are
suposed to be defined in the :ref:`input files <seclab_inputfiles>`.

Internal Coordinates in the valence model
=========================================

The use of the optional argument :option:`--ic-ids` will allow one to define the 
internal coordinates that will be included in model of the covalent 
interactions. For every internal coordinate allowed by this option, a Harmonic 
or Cosine term will be added to the covalent energy. The value of this options 
should be a comma-separated list of identifiers specifying internal coordinates 
names. Each identifier can be a specific IC name (e.g. bond/C3_cc.H1_c) or can 
be one of the following strings: *bonds*, *angles*, *diheds* or *opdists*, 
in which case all bonds, angles, ... will be included. Additionally, one can 
also define this option value using the single string *all*, in which case all 
internal coordinates in the system will be attributed a valence term. By 
default, all internal coordinates will be included in the valence model.


Parallel QuickFF
================

If Scoop is installed, it is possible to run QuickFF on multiple cores of a 
single node by using the optional argument :option:`--scoop`. Only the 
generation of the perturbation trajectories will be parallized as it is by far
the time determening step. The exact syntax to use QuickFF in parallel is::

    python -m scoop -n nproc /path/to/qff-est.py --scoop [options] fns

*nproc* is the number of processes that can be launched simultaneously. It is
important to note that one has to define the absolute path to the location of 
the `qff-est.py` script. Finally, `[options]` and `fns` have the same meaning as
in the serial version.

Miscellanous options
====================

* Output file suffix (:option:`--suffix`):
    Suffix that will be added to all output files. By default, no suffix is 
    added.

* Trajectory storing/loading (:option:`--fn-traj`):
    Depending if the given option argument corresponds to an existing file or 
    not, this option will load/save perturbation trajectories to/from a cPickled 
    file.

* Provide Yaff screen output (:option:`--yaff-output`):
    Suffix to control screen output from Yaff. Normally, this information is
    not necessary to follow the QuickFF progress. It can however be useful to
    turn on the Yaff output to debug a system and/or parameter file. By default
    this option is False, which means that no Yaff output is printed on screen.

* Avoid the construction of perturbation trajectories (:option:`--linear`):
    The construction of perturbation trajectories is the most costly step of
    the QuickFF methodology. To avoid this step, the first estimate of force
    constants and rest values can be estimated using local information only.


Output
======

During the derivation of the force field, QuickFF will dump some usefull
information to the screen including machine information, system information, 
model information, the force field parameters after the perturbation step and
the final force field parameters. Additionally, three output files are
generated:

* system.chk:

    A MolMod checkpoint file containing all system information. This file can be
    used to start new QuickFF calculations or to perform force field simulations
    using `Yaff <http://molmod.github.io/yaff/>`_ together with the file 
    pars_yaff.txt.

* pars_yaff.txt:
    
    A formatted text file defining the final force field. This file can be read
    by `Yaff <http://molmod.github.io/yaff/>`_ together with the file 
    system.chk, to perform force field simulations.

* pars_ffit2.txt

    A formatted text file defining the final force field. This file can be read
    by FFit2 to further fine tune the force field if desired.
